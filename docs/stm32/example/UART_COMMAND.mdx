---
sidebar_position: 2.631
---
# ã€UART ä¸²å£ã€‘å¾ªç¯ç¼“å†²åŒº+å‘½ä»¤è§£æ

**ä¸‹è½½ä¾‹ç¨‹ä»£ç **ï¼š <a href="https://pan.baud-dance.com/d/%E6%B3%A2%E7%89%B9%E5%BE%8B%E5%8A%A8STM32%E4%BE%8B%E7%A8%8B/UART_Command.zip" class="source_download_button" target="_blank">ä¸‹è½½ä»£ç (CubeIDE)</a> 
<a href="https://fubestore.baud.dance/UART_CirBuffer_keil.7z" class="source_download_button" target="_blank">ä¸‹è½½ä»£ç (Keil)</a>

:::warning
CubeIDEä»£ç è¯·æŒ‰ç…§ <a href="/docs/stm32/example/HowToImportExample" target="_blank">**ä¾‹ç¨‹ä½¿ç”¨æ–¹æ³•ğŸ”—**</a> å¯¼å…¥ä¾‹ç¨‹ï¼Œå¦åˆ™ä¸‹è½½çš„å¯èƒ½ä¸æ˜¯ä¾‹ç¨‹è€Œæ˜¯å…¶ä»–å·¥ç¨‹ã€‚

Keilä»£ç è¯·ä½¿ç”¨ **ArmCC V6** ç¼–è¯‘ï¼Œå¦åˆ™å¯èƒ½ä¼šå‡ºç°ç¼–è¯‘é”™è¯¯ã€‚[**ç‚¹å‡»æ­¤å¤„å®‰è£…Keil ArmCC V6ğŸ”—**](docs/stm32/keil/installKeil.mdx)
:::


## å¦‚ä½•ä½¿ç”¨ä¾‹ç¨‹

1ï¸âƒ£ ç¼–è¯‘å¹¶ä¸‹è½½ç¨‹åºåˆ°å­¦ä¹ æ¿

2ï¸âƒ£ ä½¿ç”¨é…å¥—TYPE-Cæ•°æ®çº¿ï¼Œå°†å­¦ä¹ æ¿è¿æ¥åˆ°è®¡ç®—æœº

<div style={{ display: "flex", justifyContent: "center", alignItems: "center", marginBottom: "20px"}}>
<img src={require('./img/è¿æ¥usbçº¿.webp').default} alt="è¿æ¥usbçº¿" width="400px" />
</div>

3ï¸âƒ£ æ‰“å¼€ [æ³¢ç‰¹å¾‹åŠ¨ ä¸²å£åŠ©æ‰‹](https://serial.keysking.com/) åœ¨çº¿ä¸²å£è°ƒè¯•åŠ©æ‰‹ï¼Œç‚¹å‡»â€œé€‰æ‹©ä¸²å£â€ï¼Œé€‰æ‹©USB Single Serial

4ï¸âƒ£ å‘é€ç›¸åº”çš„å‘½ä»¤æµ‹è¯•åŠŸèƒ½

çº¢è‰²å°ç¯äº®èµ·ï¼š
```
AA 05 01 01 B1
```

çº¢è‰²å°ç¯ç†„ç­ ç»¿è‰²å°ç¯äº®èµ·ï¼š
```
AA 07 01 00 02 01 B5
```

æµ‹è¯•é•¿å‘½ä»¤è§£æï¼š
```
AA 1A 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 10 11 12 13 14 15 16 17 D8
```

<div style={{ display: "flex", justifyContent: "center", alignItems: "center", marginBottom: "20px"}}>
<img src={require('./img/UART_RGB/serial.png').default} alt="ä¸²å£" width="700px" />
</div>

## ä¾‹ç¨‹è®²è§£

ä¸‹é¢ä»‹ç»äº†å¦‚ä½•è‡ªå·±å®ç°è¯¥ä¾‹ç¨‹çš„åŠŸèƒ½

### 1ã€å·¥ç¨‹é…ç½®

1ï¸âƒ£ **åˆ†é…å¼•è„š**ï¼šå¦‚å›¾ï¼Œå°† `PA6`ã€`PA7`ã€`PB0` é…ç½®ä¸º `GPIO_Output`ï¼Œå¹¶åˆ†åˆ«è®¾ç½® User label ä¸º `BLUE`ã€`GREEN`ã€`RED`
:::tip
**å·¦é”®**ç‚¹å‡»å¯¹åº”çš„å¼•è„šï¼Œé€‰æ‹© GPIO_Outputï¼›
**å³é”®**ç‚¹å‡»å¯¹åº”çš„å¼•è„šï¼Œé€‰æ‹© User labelï¼Œåˆ†åˆ«è¾“å…¥ BLUEã€GREENã€RED
:::
<div style={{ display: "flex", justifyContent: "center", alignItems: "center", marginBottom: "20px"}}>
<img src={require('./img/LED/gpio config.png').default} alt="gpio config" width="600px" />
</div>

2ï¸âƒ£ **æ‰“å¼€ä¸²å£2å¤–è®¾**ï¼š`Pinout&Configuration` -> `Connectivity` -> `USART2`ï¼Œå°† `Mode` é€‰æ‹©ä¸º `Asynchronous`

<div style={{ display: "flex", justifyContent: "center", alignItems: "center", marginBottom: "20px"}}>
<img src={require('./img/UART_RGB/configUART.png').default} alt="uart config" width="600px" />
</div>

3ï¸âƒ£ **ä½¿èƒ½ä¸²å£ä¸­æ–­**ï¼šåœ¨ USART2 -> Configuration -> NVIC Settings æ ‡ç­¾å¡ä¸­ï¼Œå‹¾é€‰ USART2 global interrupt çš„ Enable

<div style={{ display: "flex", justifyContent: "center", alignItems: "center", marginBottom: "20px"}}>
<img src={require('./img/UART_RGB/enableIT.png').default} alt="IT config" width="600px" />
</div>


### 2ã€ä»£ç 

1ï¸âƒ£ åœ¨Core/Srcæ–‡ä»¶å¤¹ä¸‹æ–°å»ºcommand.cæ–‡ä»¶

    ```c
    #include "command.h"

    // æŒ‡ä»¤çš„æœ€å°é•¿åº¦
    #define COMMAND_MIN_LENGTH 4

    // å¾ªç¯ç¼“å†²åŒºå¤§å°
    #define BUFFER_SIZE 128
    // å¾ªç¯ç¼“å†²åŒº
    uint8_t buffer[BUFFER_SIZE];
    // å¾ªç¯ç¼“å†²åŒºè¯»ç´¢å¼•
    uint8_t readIndex = 0;
    // å¾ªç¯ç¼“å†²åŒºå†™ç´¢å¼•
    uint8_t writeIndex = 0;

    /**
    * @brief å¢åŠ è¯»ç´¢å¼•
    * @param length è¦å¢åŠ çš„é•¿åº¦
    */
    void Command_AddReadIndex(uint8_t length) {
        readIndex += length;
        readIndex %= BUFFER_SIZE;
    }

    /**
    * @brief è¯»å–ç¬¬iä½æ•°æ® è¶…è¿‡ç¼“å­˜åŒºé•¿åº¦è‡ªåŠ¨å¾ªç¯
    * @param i è¦è¯»å–çš„æ•°æ®ç´¢å¼•
    */

    uint8_t Command_Read(uint8_t i) {
        uint8_t index = i % BUFFER_SIZE;
        return buffer[index];
    }

    /**
    * @brief è®¡ç®—æœªå¤„ç†çš„æ•°æ®é•¿åº¦
    * @return æœªå¤„ç†çš„æ•°æ®é•¿åº¦
    * @retval 0 ç¼“å†²åŒºä¸ºç©º
    * @retval 1~BUFFER_SIZE-1 æœªå¤„ç†çš„æ•°æ®é•¿åº¦
    * @retval BUFFER_SIZE ç¼“å†²åŒºå·²æ»¡
    */
    //uint8_t Command_GetLength() {
    //  // è¯»ç´¢å¼•ç­‰äºå†™ç´¢å¼•æ—¶ï¼Œç¼“å†²åŒºä¸ºç©º
    //  if (readIndex == writeIndex) {
    //    return 0;
    //  }
    //  // å¦‚æœç¼“å†²åŒºå·²æ»¡,è¿”å›BUFFER_SIZE
    //  if (writeIndex + 1 == readIndex || (writeIndex == BUFFER_SIZE - 1 && readIndex == 0)) {
    //    return BUFFER_SIZE;
    //  }
    //  // å¦‚æœç¼“å†²åŒºæœªæ»¡,è¿”å›æœªå¤„ç†çš„æ•°æ®é•¿åº¦
    //  if (readIndex <= writeIndex) {
    //    return writeIndex - readIndex;
    //  } else {
    //    return BUFFER_SIZE - readIndex + writeIndex;
    //  }
    //}

    uint8_t Command_GetLength() {
        return (writeIndex + BUFFER_SIZE - readIndex) % BUFFER_SIZE;
    }


    /**
    * @brief è®¡ç®—ç¼“å†²åŒºå‰©ä½™ç©ºé—´
    * @return å‰©ä½™ç©ºé—´
    * @retval 0 ç¼“å†²åŒºå·²æ»¡
    * @retval 1~BUFFER_SIZE-1 å‰©ä½™ç©ºé—´
    * @retval BUFFER_SIZE ç¼“å†²åŒºä¸ºç©º
    */
    uint8_t Command_GetRemain() {
        return BUFFER_SIZE - Command_GetLength();
    }

    /**
    * @brief å‘ç¼“å†²åŒºå†™å…¥æ•°æ®
    * @param data è¦å†™å…¥çš„æ•°æ®æŒ‡é’ˆ
    * @param length è¦å†™å…¥çš„æ•°æ®é•¿åº¦
    * @return å†™å…¥çš„æ•°æ®é•¿åº¦
    */
    uint8_t Command_Write(uint8_t *data, uint8_t length) {
        // å¦‚æœç¼“å†²åŒºä¸è¶³ åˆ™ä¸å†™å…¥æ•°æ® è¿”å›0
        if (Command_GetRemain() < length) {
            return 0;
        }
        // ä½¿ç”¨memcpyå‡½æ•°å°†æ•°æ®å†™å…¥ç¼“å†²åŒº
        if (writeIndex + length < BUFFER_SIZE) {
            memcpy(buffer + writeIndex, data, length);
            writeIndex += length;
        } else {
            uint8_t firstLength = BUFFER_SIZE - writeIndex;
            memcpy(buffer + writeIndex, data, firstLength);
            memcpy(buffer, data + firstLength, length - firstLength);
            writeIndex = length - firstLength;
        }
        return length;
    }

    /**
    * @brief å°è¯•è·å–ä¸€æ¡æŒ‡ä»¤
    * @param command æŒ‡ä»¤å­˜æ”¾æŒ‡é’ˆ
    * @return è·å–çš„æŒ‡ä»¤é•¿åº¦
    * @retval 0 æ²¡æœ‰è·å–åˆ°æŒ‡ä»¤
    */
    uint8_t Command_GetCommand(uint8_t *command) {
        // å¯»æ‰¾å®Œæ•´æŒ‡ä»¤
        while (1) {
            // å¦‚æœç¼“å†²åŒºé•¿åº¦å°äºCOMMAND_MIN_LENGTH åˆ™ä¸å¯èƒ½æœ‰å®Œæ•´çš„æŒ‡ä»¤
            if (Command_GetLength() < COMMAND_MIN_LENGTH) {
            return 0;
            }
            // å¦‚æœä¸æ˜¯åŒ…å¤´ åˆ™è·³è¿‡ é‡æ–°å¼€å§‹å¯»æ‰¾
            if (Command_Read(readIndex) != 0xAA) {
            Command_AddReadIndex(1);
            continue;
            }
            // å¦‚æœç¼“å†²åŒºé•¿åº¦å°äºæŒ‡ä»¤é•¿åº¦ åˆ™ä¸å¯èƒ½æœ‰å®Œæ•´çš„æŒ‡ä»¤
            uint8_t length = Command_Read(readIndex + 1);
            if (Command_GetLength() < length) {
            return 0;
            }
            // å¦‚æœæ ¡éªŒå’Œä¸æ­£ç¡® åˆ™è·³è¿‡ é‡æ–°å¼€å§‹å¯»æ‰¾
            uint8_t sum = 0;
            for (uint8_t i = 0; i < length - 1; i++) {
            sum += Command_Read(readIndex + i);
            }
            if (sum != Command_Read(readIndex + length - 1)) {
            Command_AddReadIndex(1);
            continue;
            }
            // å¦‚æœæ‰¾åˆ°å®Œæ•´æŒ‡ä»¤ åˆ™å°†æŒ‡ä»¤å†™å…¥command è¿”å›æŒ‡ä»¤é•¿åº¦
            for (uint8_t i = 0; i < length; i++) {
            command[i] = Command_Read(readIndex + i);
            }
            Command_AddReadIndex(length);
            return length;
        }
    }
    ```
2ï¸âƒ£ åœ¨Core/Incæ–‡ä»¶å¤¹ä¸‹æ–°å»ºcommand.hæ–‡ä»¶
```c
#ifndef INC_COMMAND_H_
#define INC_COMMAND_H_

#include "main.h"
#include <string.h>

uint8_t Command_Write(uint8_t *data, uint8_t length);

uint8_t Command_GetCommand(uint8_t *command);

#endif /* INC_COMMAND_H_ */

```

3ï¸âƒ£ åœ¨main.cä¸­ å¼•å…¥command.c å®šä¹‰ä¸²å£æ¥æ”¶æ•°ç»„ å®ç°ä¸²å£æ¥æ”¶ç©ºé—²ä¸­æ–­å›è°ƒå‡½æ•°
:::info
æ³¨æ„å°†ä»£ç å†™åˆ°å¯¹åº”çš„æ³¨é‡Šå¯¹ä¸­
:::

```c
/* Private includes ----------------------------------------------------------*/
/* USER CODE BEGIN Includes */
#include "command.h"
/* USER CODE END Includes */
```

```c
/* Private define ------------------------------------------------------------*/
/* USER CODE BEGIN PD */
uint8_t readBuffer[10];
/* USER CODE END PD */
```

```c
/* USER CODE BEGIN 0 */
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size){
	if (huart == &huart2){
		Command_Write(readBuffer, Size);
		HAL_UARTEx_ReceiveToIdle_IT(&huart2, readBuffer, sizeof(readBuffer));
	}
}
/* USER CODE END 0 */
```

3ï¸âƒ£ å¼€å¯ä¸²å£æ¥æ”¶ whileå¾ªç¯ä¸­è·å–å‘½ä»¤ æ ¹æ®å‘½ä»¤æ§åˆ¶å°ç¯
:::info
`rx_data[0]` ç¬¬ä¸€ä¸ªå­—ç¬¦ä¸ºå°ç¯ï¼ˆ0x01ï¼šçº¢è‰²ï¼Œ0x02ï¼šç»¿è‰²ï¼Œ0x03ï¼šè“è‰²ï¼‰

`rx_data[1]` ç¬¬äºŒä¸ªå­—ç¬¦ä¸ºçŠ¶æ€ï¼ˆ0ï¼šç­ï¼Œ1ï¼šäº®ï¼‰
:::
```c
/* USER CODE BEGIN 2 */
HAL_UARTEx_ReceiveToIdle_IT(&huart2, readBuffer, sizeof(readBuffer));
uint8_t command[50];
int commandLength = 0;
/* USER CODE END 2 */

/* Infinite loop */
/* USER CODE BEGIN WHILE */
while (1)
{
    commandLength = Command_GetCommand(command);
    if (commandLength != 0){
        HAL_UART_Transmit(&huart2, command, commandLength, HAL_MAX_DELAY);
        for (int i = 2; i < commandLength - 1; i += 2){
            GPIO_PinState state = GPIO_PIN_SET;
            if (command[i + 1] == 0x00){
                state = GPIO_PIN_RESET;
            }
            if (command[i] == 0x01){
                HAL_GPIO_WritePin(RED_GPIO_Port, RED_Pin, state);
            }else if (command[i] == 0x02){
                HAL_GPIO_WritePin(GREEN_GPIO_Port, GREEN_Pin, state);
            }else if (command[i] == 0x03){
                HAL_GPIO_WritePin(BLUE_GPIO_Port, BLUE_Pin, state);
            }
        }
    }

/* USER CODE END WHILE */

/* USER CODE BEGIN 3 */
}
```

    
